# -*- coding: utf-8 -*-
"""dimuon100k.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19y4N00D0bLb2Q6qg2_Z7ZjGNuialgf9p
"""

# Commented out IPython magic to ensure Python compatibility.
# import libraries
import pandas as pd
import numpy as np
# %matplotlib inline
import matplotlib as mpl
import matplotlib.pyplot as plt
import math
inline_rc = dict(mpl.rcParams)

# clear figures
plt.clf()

# The next line pulls in out data from a file with comma seperated values (csv)
data = pd.read_csv('https://raw.githubusercontent.com/dkallenberg/Quarknet_Data/master/dimuon100k.csv')

# determine the number of events
n_evt = len(data.E1)

# initialize arrays for histogram use
Esys = np.zeros((n_evt, 1), dtype=np.float)
Psys = np.zeros((n_evt, 1), dtype=np.float)
Msys = np.zeros((n_evt, 1), dtype=np.float)
P3sys = np.zeros((n_evt, 3), dtype=np.float)
P3sys_evt = np.zeros((3), dtype=np.float)
M_all = np.zeros((n_evt, 1), dtype=np.float)
M_opp = np.zeros((n_evt, 1), dtype=np.float)
M_opp_GT_GG = np.zeros((n_evt, 1), dtype=np.float)
M_opp_GG = np.zeros((n_evt, 1), dtype=np.float)
B3sys = np.zeros((n_evt, 3), dtype=np.float)

# set bin size for histograms
xE = np.linspace(0, 50, num=201)     # adjust as needed
xP = np.linspace(-15, 15, num=201)     # adjust as needed
xQ = np.linspace(-100, 100, num=201)     # adjust as needed
xEsys = np.linspace(-100, 100, num=201)  # adjust as needed
xPsys = np.linspace(-100, 100, num=201)  # adjust as needed
xM = np.linspace(-100, 100, num=201)     # adjust as needed
xERF = np.linspace(-100, 100, num=201)   # adjust as needed
xPRF = np.linspace(-100, 100, num=201)   # adjust as needed

data.head(5)

# The .shape command displays the (number of rows , number of columns) in a file.
data.shape

# The .types command displays each variable's type.
data.dtypes

"""Store the muon quality, the event number, and the charges of muons 1 and 2 in arrays. Then create 4-momentum vectors for muon 1 and muon 2."""

# initialize physics arrays 
mu1_q = np.zeros((n_evt,1), dtype=np.object)
mu2_q = np.zeros((n_evt,1), dtype=np.object)

ev_n = np.zeros((n_evt,1), dtype=np.float)
q1 = np.zeros((n_evt,1), dtype=np.int)
q2 = np.zeros((n_evt,1), dtype=np.int)
p4mu1 = np.zeros((n_evt, 4), dtype=np.float)
p4mu2 = np.zeros((n_evt, 4), dtype=np.float)
# populate physics arrays
mu1_q[:, 0] = data.Type1
mu2_q[:, 0] = data.Type2
#ev_n[:, 0] = data.Event_Number
q1[:, 0] = data.Q1
q2[:, 0] = data.Q2
# populate muon 1's 4-momentum
p4mu1[:, 0] = data.E1
p4mu1[:, 1] = data.px1
p4mu1[:, 2] = data.py1
p4mu1[:, 3] = data.pz1
# populate muon 2's 4-momentum
p4mu2[:, 0] = data.E2
p4mu2[:, 1] = data.px2
p4mu2[:, 2] = data.py2
p4mu2[:, 3] = data.pz2



# create and display diagnostic histograms
fig = plt.figure(1, figsize=[12,10])
fig.suptitle('Figure #1: Diagnostic Plots in Lab Frame')

#1
plt.subplot(3, 4, 1)
plt.hist(mu1_q)
plt.xlabel('Muon1 Quality')

#2
plt.subplot(3, 4, 2)
plt.hist(mu2_q)
plt.xlabel('Muon2 Quality')

#3
plt.subplot(3, 4, 3)
plt.hist(p4mu1[:, 0], xE)
plt.xlabel('Energy 1 (GeV)')

#4
plt.subplot(3, 4, 4)
plt.hist(p4mu1[:, 1], xP)
plt.xlabel('Px1')

#5
plt.subplot(3, 4, 5)
plt.hist(p4mu1[:, 2], xP)
plt.xlabel('Py1')

#6
plt.subplot(3, 4, 6)
plt.hist(p4mu1[:, 3], xP)
plt.xlabel('Pz1')

#7
plt.subplot(3, 4, 7)
plt.hist(q1[:, 0])
plt.xlabel('Charge 1')

#8
plt.subplot(3, 4, 8)
plt.hist(p4mu2[:, 0], xE)
plt.xlabel('Energy 2 (GeV)')

#9
plt.subplot(3, 4, 9)
plt.hist(p4mu2[:, 1], xP)
plt.xlabel('Px2')

#10
plt.subplot(3, 4, 10)
plt.hist(p4mu2[:, 2], xP)
plt.xlabel('Py2')

#11
plt.subplot(3, 4, 11)
plt.hist(p4mu2[:, 3], xP)
plt.xlabel('Pz2')

#12
plt.subplot(3, 4, 12)
plt.hist(q2[:, 0])
plt.xlabel('Charge 2')

"""
plt.subplot(3, 4, 5)
plt.hist(p4mu1[:, 0], xE)
plt.xlabel('E1 (GeV)')
"""


# calculate Esys, P3sys, Psys (magnitude of 3 momentum) and Msys

for ie in range(0, n_evt):
    Esys[ie, 0] = p4mu1[ie, 0] + p4mu2[ie, 0]
    P3sys[ie, 0:3] = [p4mu1[ie, 1] + p4mu2[ie, 1],  p4mu1[ie, 2] + p4mu2[ie, 2], p4mu1[ie, 3] + p4mu2[ie, 3]]
    Psys[ie, 0] = math.sqrt(P3sys[ie, 0] ** 2 + P3sys[ie, 1] ** 2 + P3sys[ie, 2] ** 2) 
    #Msys[ie, 0] = math.sqrt(Esys[ie, 0] - math.sqrt(Psys[ie,0]))
    Msys[ie, 0] = math.sqrt(Esys[ie, 0]**2 - Psys[ie,0]**2)

# histogram Esys, Psys (magnitude of 3 momentum) and Msys
fig = plt.figure(2, figsize=[18,8])
fig.suptitle('Figure #2: Esys, Psys and Msys in Lab Frame')

xEsys = np.linspace(0, 60, num=201)     # adjust as needed
xPsys = np.linspace(0, 60, num=201)     # adjust as needed
xMsys = np.linspace(1, 10, num=201)     # adjust as needed

plt.subplot(1, 3, 1)
plt.hist(Esys, xEsys)
plt.xlabel('Energy of system (Gev)')

plt.subplot(1, 3, 2)
plt.hist(Psys, xPsys)
plt.xlabel('P of system (Gev)')

plt.subplot(1, 3, 3)
plt.hist(Msys, xMsys)
plt.xlabel('Mass of system (Gev')


print(Esys)
print('-'*50)
print(P3sys)
print('-'*50)
print(Psys)
print('-'*50)
print(Msys)


# select events based on the charge and muon quality
for ie in range(0, n_evt):
    M_all[ie, 0] = Msys[ie, 0]
    if ((q1[ie] * q2[ie]) < 0):
        M_opp[ie, 0] = Msys[ie, 0]
    if ((q1[ie] * q2[ie]) < 0) and mu1_q[ie, 0] == 'T' and mu2_q[ie,0] == 'G' :
        M_opp_GT_GG[ie, 0] = Msys[ie, 0]
    if ((q1[ie] * q2[ie]) < 0) and mu1_q[ie, 0] == 'G' and mu2_q[ie,0] == 'T' :
        M_opp_GT_GG[ie, 0] = Msys[ie, 0]
    if ((q1[ie] * q2[ie]) < 0) and mu1_q[ie, 0] == 'G' and mu2_q[ie,0] == 'G':
        M_opp_GG[ie, 0] = Msys[ie, 0]


# histogram Esys, Psys (magnitude of 3 momentum) and Msys
fig = plt.figure(3, figsize=[18,12])
fig.suptitle('Figure #3: Muon Charge and Quality Cuts in Lab Frame')

#xEsys = np.linspace(0, 60, num=201)     # adjust as needed
#xPsys = np.linspace(0, 60, num=201)     # adjust as needed
#xMsys = np.linspace(1, 5, num=201)     # adjust as needed

plt.subplot(2, 2, 1)
plt.hist(M_all, np.linspace(0, 6,num=200))
plt.xlabel('All pairs')

plt.subplot(2, 2, 2)
plt.hist(M_opp, np.linspace(1, 6, num=200))
plt.xlabel('opp q pairs')

plt.subplot(2, 2, 3)
plt.hist(M_opp_GT_GG, np.linspace(1,6,num=200))
plt.xlabel('opp q pairs w/TT')

plt.subplot(2, 2, 4)
plt.hist(M_opp_GG, np.linspace(1, 6, num=200))
plt.xlabel('opp q pairs w/GG')

#print(M_opp_GG)
#print(mu_q)

# histogram mass plots with muon charge and muon quality selections (cuts)
#fig = plt.figure(3)
#fig.suptitle('Figure #3: Muon Charge and Quality Cuts in Lab Frame')

# TRANSFORM to REST FRAME of CANDIDATE J/Psi

# Loop over all the events

for ie in range(0, n_evt):
    B3sys[ie, :] = P3sys[ie, :]/Esys[ie, 0]
    Bsys = np.sqrt(B3sys[ie,0]**2 + B3sys[ie,1] **2 + B3sys[ie,2] **2)

    Bx = B3sys[ie,0]
    By = B3sys[ie,1]
    Bz = B3sys[ie,2]
    y = 1/np.sqrt(1-Bsys**2)

    m11 = y
    m12 = -y * Bx
    m13 = -y * By
    m14 = -y * Bz
    m21 = -y * Bx
    m22 = 1 + (y-1)*((Bx**2)/(Bsys**2))
    m23 = (y-1)*((Bx * By)/(Bsys**2))
    m24 = (y-1)*((Bx * Bz)/(Bsys**2))
    m31 = -y * By
    m32 = (y-1)*((By * Bx)/(Bsys**2))
    m33 = 1 + (y-1)*((By**2)/(Bsys**2))
    m34 = (y-1)*((By * Bz)/(Bsys**2))
    m41 = -y * Bz
    m42 = (y-1)*((Bz * Bx)/(Bsys**2))
    m43 = (y-1)*((Bz * By)/(Bsys**2))
    m44 = 1 + (y-1)*((Bz**2)/(Bsys**2))

    # create Lorentz Transformation matrix
    #       y             -yBx                   -yBy                 -yBz
  
    L = [[  m11,           m12,                   m13,                 m14,],
         [  m21,           m22,                   m23,                 m24,],
         [  m31,           m32,                   m33,                 m34,],
         [  m41,           m42,                   m43,                 m44,]]

# transform p4mu1 and p4mu2 to rest frame of J/Psi candidate
    p4mu1[ie, 0:4] = np.transpose(L@np.transpose(p4mu1[ie, 0:4]))
    p4mu2[ie, 0:4] = np.transpose(L@np.transpose(p4mu2[ie, 0:4]))

    Esys[ie, 0] = p4mu1[ie, 0] + p4mu2[ie, 0]
    P3sys[ie, 0:3] = [p4mu1[ie, 1] + p4mu2[ie, 1],  p4mu1[ie, 2] + p4mu2[ie, 2], p4mu1[ie, 3] + p4mu2[ie, 3]]
    Psys[ie, 0] = math.sqrt(P3sys[ie, 0] ** 2 + P3sys[ie, 1] ** 2 + P3sys[ie, 2] ** 2) 
    #Msys[ie, 0] = math.sqrt(Esys[ie, 0] - math.sqrt(Psys[ie,0]))
    Msys[ie, 0] = math.sqrt(Esys[ie, 0]**2 - Psys[ie,0]**2)

xE = np.linspace(0, 5, num=201)     # adjust as needed
xP = np.linspace(-3, 3, num=201)     # adjust as needed
xQ = np.linspace(-100, 100, num=201)     # adjust as needed

fig = plt.figure(4, figsize=[12,10])
fig.suptitle('Figure #4: Diagnostic Plots in J/Psi Rest Frame')

#1
plt.subplot(3, 4, 1)
plt.hist(mu_q)
plt.xlabel('Muon Quality')

#2
plt.subplot(3, 4, 2)
plt.hist(ev_n)
plt.xlabel('Event Number')

#3
plt.subplot(3, 4, 3)
plt.hist(p4mu1[:, 0], xE)
plt.xlabel('Energy 1 (GeV)')

#4
plt.subplot(3, 4, 4)
plt.hist(p4mu1[:, 1], xP)
plt.xlabel('Px1')

#5
plt.subplot(3, 4, 5)
plt.hist(p4mu1[:, 2], xP)
plt.xlabel('Py1')

#6
plt.subplot(3, 4, 6)
plt.hist(p4mu1[:, 3], xP)
plt.xlabel('Pz1')

#7
plt.subplot(3, 4, 7)
plt.hist(q1[:, 0])
plt.xlabel('Charge 1')

#8
plt.subplot(3, 4, 8)
plt.hist(p4mu2[:, 0], xE)
plt.xlabel('Energy 2 (GeV)')

#9
plt.subplot(3, 4, 9)
plt.hist(p4mu2[:, 1], xP)
plt.xlabel('Px2')

#10
plt.subplot(3, 4, 10)
plt.hist(p4mu2[:, 2], xP)
plt.xlabel('Py2')

#11
plt.subplot(3, 4, 11)
plt.hist(p4mu2[:, 3], xP)
plt.xlabel('Pz2')

#12
plt.subplot(3, 4, 12)
plt.hist(q2[:, 0])
plt.xlabel('Charge 2')

fig = plt.figure(5, figsize=[18,12])
fig.suptitle('Figure #5: Esys, Psys and Msys in Rest Frame')

xEsys = np.linspace(0, 6, num=201)     # adjust as needed
xPsys = np.linspace(0, 6, num=201)     # adjust as needed
xMsys = np.linspace(1, 6, num=201)     # adjust as needed

plt.subplot(1, 3, 1)
plt.hist(Esys, xEsys)
plt.xlabel('Energy of system (Gev)')

plt.subplot(1, 3, 2)
plt.hist(Psys, xPsys)
plt.xlabel('P of system (Gev)')

plt.subplot(1, 3, 3)
plt.hist(Msys, xMsys)
plt.xlabel('Mass of system (Gev')

fig = plt.figure(6, figsize=[26,12])
fig.suptitle('Figure #6: Muon Charge and Quality Cuts in Rest Frame')


plt.subplot(2, 2, 1)
plt.hist(M_all, np.linspace(0, 6,num=200))
plt.xlabel('All pairs')

plt.subplot(2, 2, 2)
plt.hist(M_opp, np.linspace(1, 6, num=200))
plt.xlabel('opp q pairs')

plt.subplot(2, 2, 3)
plt.hist(M_opp_GT_GG, np.linspace(1,6,num=200))
plt.xlabel('opp q pairs w/TT')

plt.subplot(2, 2, 4)
plt.hist(M_opp_GG, np.linspace(1, 5, num=200))
plt.xlabel('opp q pairs w/GG')
